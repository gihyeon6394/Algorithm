# 5. 응용

- 여러 종류의 데이터 타입에 대한 정렬
- 어떤 정렬 알고리즘을 사용해야하는가?
- 환원
- 정렬 응용 예 간략히 살펴보기

---

- 정렬 알고리즘과 우선순위 큐는 광범위한 분야에서 다양하게 사용됨
- 정렬을 이용하는 이유 : 무작위 배열보다 정렬된 배열에서 찾는 것이 더 빠르기 때문
    - e.g. 전화번호부 이름 정렬, 플레이 리스트 글 제목 순 정렬 등
    - 데이터 압축, 컴퓨터 그래픽스, 전산 생물학, 공급망 관리, 조합 최적화, 투표 등
- 시스템에서 자체적으로 제공하는 정렬 라이브러리는 중요한 도구

## 여러 종류의 데이터 타입에 대한 정렬

- Java는 `Comparable` 구현체는 정렬을 수행할 수 있게 해줌
    - `Comparable` 구현 = `compareTo()` 메소드 구현
    - String, Integer, File, URL 등의 타입은 이미 구현하고 있음
- 많은 어플리케이션은 사용자 정의 데이터 타입으로 동작함
    - 개발자가 직접 `Comparable` 를 구현해야함

### 트랜잭션 처리 응용 예

````
// 트랜잭션의 거래 날짜를 기준으로 정렬
public int compareTo(Transaction tr){
    return this.when.compareTo(tr.when); // when은 Date 타입
}
````

- 상거래 데이터 처리는 가장 원초적으로 정렬을 필요로하는 응용 분야
- 전자 상거래에서 고객 계정의 수백만건 거래 정보를 처리할 때 정렬해서 처리하면 편함
- 거래 데이터 타입에 `compareTo()` 를 구현하여 정렬 순서를 정함
- `Transaction` 클래스에 `compareTo()` 메소드 구현
    - `Quick.sort(transactions)` 로 정렬 가능
    - `comapreTo()` 구현 내용에 정렬 기준을 정함 (e.g. 날짜, 금액 등)

### 포인터 정렬

- 포인터 정렬 : 항목들의 참조를 옮길 뿐, 실제 데이터 이동을 하지 않는 정렬
    - 즉, 객체의 참조(포인터) 를 대상으로 작업할 뿐 객체 자체를 다루지 않음
- C/C++ 에서는 포인터를 대상으로 정렬할지, 데이터를 대상으로 정렬할지 명시적으로 선택
- Java는 기본형을 제외하고는 암묵적으로 포인터 연산이 적용

### 키 값은 변하지 않는다

- 클라이언트가 이미 정렬된 키의 값을 바꾼다면, 배열은 정렬된 상태로 남기 어려움 (우선순위 큐도 마찬가지)
- Java에서는 불변 속성 타입을 사용하여 l키 값이 변경되지 않도록 하는 것이 바람직함
    - e.g. String, Integer, Double, File 등

### 교환 연산은 비용이 크다

- 참조의 장점 : 참조를 사용하여 전체 항목을 이동시키는 비용 회피
- 항목이 많고, 키가 작으면 효과 증가
    - 비교 연산 중에 항목의 일부만 이용되고 대부분을 차지하는 데이터는 접근조차 되지 않기 때문
- 참조를 사용하면 데이터의 크기가 어떻든 관계없이 교환 비용이 거의 비슷하게 됨

### 여러가지 정렬 순서

### 복수의 키를 가지는 항목

### 안정성

## 어떤 정렬 알고리즘을 사용해야하는가?

## 환원

## 정렬 응용 예 간략히 살펴보기
