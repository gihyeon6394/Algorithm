# 5. 응용

- 여러 종류의 데이터 타입에 대한 정렬
- 어떤 정렬 알고리즘을 사용해야하는가?
- 환원
- 정렬 응용 예 간략히 살펴보기

---

- 정렬 알고리즘과 우선순위 큐는 광범위한 분야에서 다양하게 사용됨
- 정렬을 이용하는 이유 : 무작위 배열보다 정렬된 배열에서 찾는 것이 더 빠르기 때문
    - e.g. 전화번호부 이름 정렬, 플레이 리스트 글 제목 순 정렬 등
    - 데이터 압축, 컴퓨터 그래픽스, 전산 생물학, 공급망 관리, 조합 최적화, 투표 등
- 시스템에서 자체적으로 제공하는 정렬 라이브러리는 중요한 도구

## 여러 종류의 데이터 타입에 대한 정렬

- Java는 `Comparable` 구현체는 정렬을 수행할 수 있게 해줌
    - `Comparable` 구현 = `compareTo()` 메소드 구현
    - String, Integer, File, URL 등의 타입은 이미 구현하고 있음
- 많은 어플리케이션은 사용자 정의 데이터 타입으로 동작함
    - 개발자가 직접 `Comparable` 를 구현해야함

### 트랜잭션 처리 응용 예

````
// 트랜잭션의 거래 날짜를 기준으로 정렬
public int compareTo(Transaction tr){
    return this.when.compareTo(tr.when); // when은 Date 타입
}
````

- 상거래 데이터 처리는 가장 원초적으로 정렬을 필요로하는 응용 분야
- 전자 상거래에서 고객 계정의 수백만건 거래 정보를 처리할 때 정렬해서 처리하면 편함
- 거래 데이터 타입에 `compareTo()` 를 구현하여 정렬 순서를 정함
- `Transaction` 클래스에 `compareTo()` 메소드 구현
    - `Quick.sort(transactions)` 로 정렬 가능
    - `comapreTo()` 구현 내용에 정렬 기준을 정함 (e.g. 날짜, 금액 등)

### 포인터 정렬

- 포인터 정렬 : 항목들의 참조를 옮길 뿐, 실제 데이터 이동을 하지 않는 정렬
    - 즉, 객체의 참조(포인터) 를 대상으로 작업할 뿐 객체 자체를 다루지 않음
- C/C++ 에서는 포인터를 대상으로 정렬할지, 데이터를 대상으로 정렬할지 명시적으로 선택
- Java는 기본형을 제외하고는 암묵적으로 포인터 연산이 적용

### 키 값은 변하지 않는다

- 클라이언트가 이미 정렬된 키의 값을 바꾼다면, 배열은 정렬된 상태로 남기 어려움 (우선순위 큐도 마찬가지)
- Java에서는 불변 속성 타입을 사용하여 l키 값이 변경되지 않도록 하는 것이 바람직함
    - e.g. String, Integer, Double, File 등

### 교환 연산은 비용이 크다

- 참조의 장점 : 참조를 사용하여 전체 항목을 이동시키는 비용 회피
- 항목이 많고, 키가 작으면 효과 증가
    - 비교 연산 중에 항목의 일부만 이용되고 대부분을 차지하는 데이터는 접근조차 되지 않기 때문
- 참조를 사용하면 데이터의 크기가 어떻든 관계없이 교환 비용이 거의 비슷하게 됨

### 여러가지 정렬 순서

````
// Comparator 를 이용한 삽입 정렬
public static void sort(Object[] a, Comparator c){
    int N = a.length;
    
    for (int i = 1; i < N; i++)
        for (int j = i; j > 0 && less(c, a[j], a[j-1]); j--
            exch(a, j, j-1);
}

// Comparator의 compare()를 이용한 비교연산
private static boolean less(Comparator c, Object v, Object w){
    return c.compare(v, w) < 0;   
}

private static void exch(Object[] a, int i, int j){
...
````

- 같은 객체들에 대해서 상황에 따라 서로 다른 정렬 순서를 활용해야하는 경우
- Java `Comparator` 인터페이스를 구현하여 하나의 클래스에서 여러 종류의 순서를 정의 가능
- `Comparator`의 `compare()` : 데이터 타입이 `Comparator`를 구현하고 있다면, 정렬 가능
- TODO. Comparable과 Comparator의 차이점
    - Comparable 대신 Comparator를 사용하면, 타입의 정의와 두 객체의 비교방식에대한 정의를 구조적으로 분리할 수 있음
    - Comparator는 비교기준을 자유롭게 선택 가능 e.g. 문자열 타입의 배열을 대소문자 구별을 무시하고 정렬할 때
- Java의 String은 이미 많은 종류의 Comparator 제공
    - e.g. `String.CASE_INSENSITIVE_ORDER`

### 복수의 키를 가지는 항목

```java
public class Transaction {
    // ...

    private final Stirng who;
    private final Date when;
    private final double amount;

    public static class AmountOrder implements Comparator<Transaction> {
        public int compare(Transaction v, Transcation w) {
            return v.amount.compareTo(w.amount);
        }
    }

    public static class WhenOrder implements Comparator<Transaction> {
        public int compare(Transaction v, Transcation w) {
            return v.when.compareTo(w.amount);
        }
    }

    public static void main(String[] args) {
        // 거래 금액으로 정렬
        Insertion.sort(a, new Transaction.AmountOrder());
        // 거래 일시로 정렬
        Insertion.sort(a, new Transaction().WhenOrder());
    }
}

```

- 대부분의 항목 객체는 여러 인스턴스 변수들로 이루어짐
- 각 인스턴스 변수들을 적절히 정렬 키로 활용해야하는 경우
    - e.g. `Transaction`을 정렬할 때 기업 고객은 거래 금액으로 정렬하고, 개인 고객은 거래 날짜로 정렬

### 안정성

- 안정 정렬 : 정렬 후에도 같은 키들의 상대적인 순서가 정렬 이전과 동일하게 정렬하는 것
- e.g. 인터넷 상거래 어플리케이션의 위치/시간 정보가 포함된 이벤트들
    1. 이벤트가 도착하는대로 배열에 저장 (시간 순서대로)
    2. 추가적인 처리를 위해 위치를 기준으로 분할
        - 위치를 기준으로 배열을 정렬하면 안정정렬되지 않아 기존의 시간순서를 보장하지 못함
- 안정 정렬 : 삽입 정렬, 병합 정렬
- 안정 정렬 X : 선택 정렬, 셸-정렬, 퀵-정렬, 힙-정렬
    - 안정적으로 만드는 트릭을 추가해야함
    - 현실적으로 구현이 쉽지는 않음 (어플리케이션 개발자들이 사용하기에는 너무 복잡)
- 안정성이 피룡하다면 기본적으로 안정정렬을 지원하는 삽입, 병합 정렬을 사용하는 것이 바람직

// TODO. 이미지

## 어떤 정렬 알고리즘을 사용해야하는가?

- 상숫값 : 주로 구현 내용, 자바 컴파일러, 사용하는 컴퓨터에 종속적 (얼마나 많은 기계어가 수행되고, 각 기계어마다 필요한 수행 시간)
- 셸-정렬, 삽입 정렬, 퀵 정렬은 상숫값을 곱하는 방식으로 실행시간 예측 불가능

| 알고리즘     | 안정정렬 | 즉석정렬 | N개 항목에 대한 증가오더 (실행시간) | N개 항목에 대한 증가오더 (추가 공간) | 비고                  |
|----------|------|------|-----------------------|------------------------|---------------------|
| 선택정렬     | X    | O    | N^2                   | 1                      | 항목들의 입력 순서ㅔ 종속적     |
| 삽입정렬     | O    | O    | N에서  N^2 사이           | 1                      |                     |
| 셸-정렬     | X    | O    | Nlog, N?, N^6/5       | 1                      |                     |
| 퀵-정렬     | X    | O    | NlogN                 | lgN                    | 확률적으로 보증됨           |
| 3-중 퀵-정렬 | X    | O    | N에서 NlogN 사이          | lgN                    | 확률적인 동시에 입력 키들에 종속적 |
| 병합정렬     | O    | X    | NlogN                 | N                      |                     |
| 힙-정렬     | X    | O    | NlogN                 | 1                      |                     |

#### 명제 : 퀵-정렬은 가장 빠른 범용 정렬 알고리즘이다

증명 : 위 가설은 퀵-정렬이 개발된 이래 수십년동안 수많은 컴퓨팅 시스템에서 수많은 방식으로 구현되어왔다.  
일반적으로 퀵정렬이 빠른 이유는 내부루프의 명령어 수가 적기 때문이다

- 결론 : 대부분의 실제적인 상황에서 퀵-정렬을 선택하는 것이 안전하다
- 그 선택이 올바른지는 예외상황들을 토대로 살펴봐야한다.
    - e.g. 정렬 안정성이 중요하고 공간이 충분하면 병합 정렬이 최선

### 기본 데이터 타입에 대한 정렬

- 성능에 매우 민감하고, 숫자의 정렬에만 집중할거면, int와 같은 기본형을 사용하는 것
- int를 정렬할 떄 : 숫자 자체를 교환하며 배열에서 데이터 위치를 바꿔나감
    - `compareTo()`, `less()` 필요 없음
    - `a[i] < a[j]`로 대체
- Integer를 정렬할 때 : 숫자 객체를 담고있는 참조를 교환
    - 참조들을 정렬하는 비용 + 숫자 값에 접근하기 위해 참조를 거치는 비용

### 자바 시스템 내장 정렬 기능

- 자바 자체적으로 제공하는 정렬 메서드 `java.util.Arrays.sort()`
- 오버로딩 되어있음
    - 각 기본형 타입 버전
        - 3중 분할 퀵-정렬로 구현되어있음
    - `Comparable` 구현체 버전
    - `Comparator` 구현체 버전
    - 객체 참조 타입 버전에는 벼압 정렬 이용
- 자바 개발 시 `compareTo()`, `comapre()`만 구현하고 `Arrays.sort()`로 충분한 경우도 있음

## 환원

- 환원 : 어떤 문제를 위해 개발된 알고리즘이 다른 문제 해결에 활용되는 것
    - 문제 A를 문제 B로 환원 : 문제 B를 위해 작성된 메서드를 문제 A에 활용
- 환원은 기초적인 알고리즘 이론에 있어서 매우 중요한 역할

### 중복

````
// 배열 a에서 서로 다른 유일한 키 값들을 출력
Quick.sort(a); // 정렬

int cnt = 1; 
for(int i = 1; i < a.length; i++)
    if(a[i].compareTo(a[i-1]) != 0)
        cnt++;
````

- `Comparable` 객체 타입 배열 안에 얼마나 많은 중복 키들이 있는가?
- 정렬을 통해 선형 로그 시간에 해결 가능

### 랭킹

- **순열 (또는 랭킹)** : N개의 정수로 이루어진 배열
- 0에서 N-1에 이르는 숫자가 정확히 한번씩만 등장
- 캔달 타우 거리 (Kendall tau distance) : 두 순열에서 서로 다른 순서로 놓여있는 숫자 쌍의 갯수
    - 0, 3, 1, 6, 2, 5, 4와 1, 0, 3, 6, 4, 2, 5의 캔달 타우 거리는 4
        - 0-1, 3-1, 2-4, 5-4

### 우선순위 큐 환원

- 크기 M인 우선순위 큐로 환원
- `TopM` : 가장 큰 M개의 항목을 찾음
- `Multiway` : M개의 정렬된 입력 스트림을 하나의 정렬된 출력 스트림으로 병합

### 중앙값과 순위 통계

- 어떤 키 집합에서 중앙값을 찾을 때 정체 배열을 정렬하지 않아도 됨
- 키 선택 문제 : 집합에서 k번째로 작은 숫자를 찾는 것

````
// 배열 a에서 k번째로 작원 원소 선택
public static Comparable seelct(Comparable[] a, int k){
    StdRandom.shuffle(a);
    int l = 0, hi = a.length -1;
    
    while (hi > lo){
        int j = partition(a, lo, hi);
        if (j == k) return a[k];    // 찾음
        else if (j > k) hi = j -1;  // j 왼쪽에서 찾음 
        else if (j < k) lo = j + 1; // j 오른쪽에서 찾음 
    }
   
   return a[k];
}
````

- `partition()`의 결과로 j 왼쪽에는 j보다 작거나 같은 항목, 오른쪽에는 j보다 같거나 큰 항목이 위치함을 이용

// TODO. 이미지

## 정렬 응용 예 간략히 살펴보기
