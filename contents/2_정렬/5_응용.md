# 5. 응용

- 여러 종류의 데이터 타입에 대한 정렬
- 어떤 정렬 알고리즘을 사용해야하는가?
- 환원
- 정렬 응용 예 간략히 살펴보기

---

- 정렬 알고리즘과 우선순위 큐는 광범위한 분야에서 다양하게 사용됨
- 정렬을 이용하는 이유 : 무작위 배열보다 정렬된 배열에서 찾는 것이 더 빠르기 때문
    - e.g. 전화번호부 이름 정렬, 플레이 리스트 글 제목 순 정렬 등
    - 데이터 압축, 컴퓨터 그래픽스, 전산 생물학, 공급망 관리, 조합 최적화, 투표 등
- 시스템에서 자체적으로 제공하는 정렬 라이브러리는 중요한 도구

## 여러 종류의 데이터 타입에 대한 정렬

- Java는 `Comparable` 구현체는 정렬을 수행할 수 있게 해줌
    - `Comparable` 구현 = `compareTo()` 메소드 구현
    - String, Integer, File, URL 등의 타입은 이미 구현하고 있음
- 많은 어플리케이션은 사용자 정의 데이터 타입으로 동작함
    - 개발자가 직접 `Comparable` 를 구현해야함

### 트랜잭션 처리 응용 예

````
// 트랜잭션의 거래 날짜를 기준으로 정렬
public int compareTo(Transaction tr){
    return this.when.compareTo(tr.when); // when은 Date 타입
}
````

- 상거래 데이터 처리는 가장 원초적으로 정렬을 필요로하는 응용 분야
- 전자 상거래에서 고객 계정의 수백만건 거래 정보를 처리할 때 정렬해서 처리하면 편함
- 거래 데이터 타입에 `compareTo()` 를 구현하여 정렬 순서를 정함
- `Transaction` 클래스에 `compareTo()` 메소드 구현
    - `Quick.sort(transactions)` 로 정렬 가능
    - `comapreTo()` 구현 내용에 정렬 기준을 정함 (e.g. 날짜, 금액 등)

### 포인터 정렬

- 포인터 정렬 : 항목들의 참조를 옮길 뿐, 실제 데이터 이동을 하지 않는 정렬
    - 즉, 객체의 참조(포인터) 를 대상으로 작업할 뿐 객체 자체를 다루지 않음
- C/C++ 에서는 포인터를 대상으로 정렬할지, 데이터를 대상으로 정렬할지 명시적으로 선택
- Java는 기본형을 제외하고는 암묵적으로 포인터 연산이 적용

### 키 값은 변하지 않는다

- 클라이언트가 이미 정렬된 키의 값을 바꾼다면, 배열은 정렬된 상태로 남기 어려움 (우선순위 큐도 마찬가지)
- Java에서는 불변 속성 타입을 사용하여 l키 값이 변경되지 않도록 하는 것이 바람직함
    - e.g. String, Integer, Double, File 등

### 교환 연산은 비용이 크다

- 참조의 장점 : 참조를 사용하여 전체 항목을 이동시키는 비용 회피
- 항목이 많고, 키가 작으면 효과 증가
    - 비교 연산 중에 항목의 일부만 이용되고 대부분을 차지하는 데이터는 접근조차 되지 않기 때문
- 참조를 사용하면 데이터의 크기가 어떻든 관계없이 교환 비용이 거의 비슷하게 됨

### 여러가지 정렬 순서

````
// Comparator 를 이용한 삽입 정렬
public static void sort(Object[] a, Comparator c){
    int N = a.length;
    
    for (int i = 1; i < N; i++)
        for (int j = i; j > 0 && less(c, a[j], a[j-1]); j--
            exch(a, j, j-1);
}

// Comparator의 compare()를 이용한 비교연산
private static boolean less(Comparator c, Object v, Object w){
    return c.compare(v, w) < 0;   
}

private static void exch(Object[] a, int i, int j){
...
````

- 같은 객체들에 대해서 상황에 따라 서로 다른 정렬 순서를 활용해야하는 경우
- Java `Comparator` 인터페이스를 구현하여 하나의 클래스에서 여러 종류의 순서를 정의 가능
- `Comparator`의 `compare()` : 데이터 타입이 `Comparator`를 구현하고 있다면, 정렬 가능
- TODO. Comparable과 Comparator의 차이점
    - Comparable 대신 Comparator를 사용하면, 타입의 정의와 두 객체의 비교방식에대한 정의를 구조적으로 분리할 수 있음
    - Comparator는 비교기준을 자유롭게 선택 가능 e.g. 문자열 타입의 배열을 대소문자 구별을 무시하고 정렬할 때
- Java의 String은 이미 많은 종류의 Comparator 제공
    - e.g. `String.CASE_INSENSITIVE_ORDER`

### 복수의 키를 가지는 항목

```java
public class Transaction {
    // ...

    private final Stirng who;
    private final Date when;
    private final double amount;

    public static class AmountOrder implements Comparator<Transaction> {
        public int compare(Transaction v, Transcation w) {
            return v.amount.compareTo(w.amount);
        }
    }

    public static class WhenOrder implements Comparator<Transaction> {
        public int compare(Transaction v, Transcation w) {
            return v.when.compareTo(w.amount);
        }
    }

    public static void main(String[] args) {
        // 거래 금액으로 정렬
        Insertion.sort(a, new Transaction.AmountOrder());
        // 거래 일시로 정렬
        Insertion.sort(a, new Transaction().WhenOrder());
    }
}

```

- 대부분의 항목 객체는 여러 인스턴스 변수들로 이루어짐
- 각 인스턴스 변수들을 적절히 정렬 키로 활용해야하는 경우
    - e.g. `Transaction`을 정렬할 때 기업 고객은 거래 금액으로 정렬하고, 개인 고객은 거래 날짜로 정렬

### 안정성

- 안정 정렬 : 정렬 후에도 같은 키들의 상대적인 순서가 정렬 이전과 동일하게 정렬하는 것
- e.g. 인터넷 상거래 어플리케이션의 위치/시간 정보가 포함된 이벤트들
    1. 이벤트가 도착하는대로 배열에 저장 (시간 순서대로)
    2. 추가적인 처리를 위해 위치를 기준으로 분할
        - 위치를 기준으로 배열을 정렬하면 안정정렬되지 않아 기존의 시간순서를 보장하지 못함
- 안정 정렬 : 삽입 정렬, 병합 정렬
- 안정 정렬 X : 선택 정렬, 셸-정렬, 퀵-정렬, 힙-정렬
    - 안정적으로 만드는 트릭을 추가해야함
    - 현실적으로 구현이 쉽지는 않음 (어플리케이션 개발자들이 사용하기에는 너무 복잡)
- 안정성이 피룡하다면 기본적으로 안정정렬을 지원하는 삽입, 병합 정렬을 사용하는 것이 바람직

// TODO. 이미지

## 어떤 정렬 알고리즘을 사용해야하는가?

## 환원

## 정렬 응용 예 간략히 살펴보기
