# 4. 우선순위 큐 (Priority Queues)

- API
- 기초적인 구현
- 힙(heap)의 정의
- 힙을 이용한 알고리즘
- 힙-정렬

---

- 꼭 모든 키가 정렬된 뒤 알고리즘을 수행할 필요가 없을 때
- 부분적인 항목에서 가장 큰 키를 찾음 -> ... (다른 로직 수행) -> 부분적인 항목에서 가장 큰 키를 찾음 -> ... (다른 로직 수행) -> ...
- e.g. 스마트폰의 여러 프로세스 중 전화가 오면 전화 앱이 가장 먼저 구동됨

### 우선순위 큐 (Priority Queues)

- 최댓값 항목 삭제 (꺼내기), 새로운 항목 추가 를 지원하는 데이터 타입
- 이진 힙 (binary heap) : 전통적인 우선순위 큐
    - 배열에 항목을 저장하되 삽입/최댓값 항목 삭제 작업이 logN 시간 안에 이루어지도록 구현
- 응용 상황
    - 시뮬레이션에서 키 (이벤트의 타이밍)를 시간순서에 맞추어 처리
    - 작업 스케줄링에서 키(작업 우선순위) 중 우선순위가 높은 작업을 먼저 처리
- 우선순위 큐를 이용한 정렬 알고리즘
    - 항목들을 모두 큐에 넣음 작은 순서대로 꺼내면 정렬 완료
    - 힙-정렬 : 힙을 이용한 우선순위 큐

## API

- 우선순위 큐의 2가지 연산 : 최댓값 항목 삭제 + 삽입
- 최댓값 항목 삭제 연산 : 가장 큰 키값을 가진 임의의 항목을 삭제
    - `delMax()`
- 삽입 연산 : 새로운 항목을 삽입
    - `insert()`
- `MaxPQ.delMax()` : `MaxPQ` 큐에서 최댓값 항목을 삭제
- `MinPQ.delMin()` : `MinPQ` 큐에서 최솟값 항목을 삭제

| API                  | 설명                                |
|----------------------|-----------------------------------|
| `MaxPQ()`            | 최댓값 항목 삭제 + 삽입 연산을 지원하는 우선순위 큐 생성 |
| `MaxPQ(int max)`     | 큐의 최대 크기를 지정하며 생성                 |
| `MaxPQ(Key[] a)`     | `a[]`의 항목들로 구성된 우선순위 큐 생성         |
| `void insert(Key v)` | 우선순위 큐에 `v`를 삽입                   |
| `Key max()`          | 우선순위 큐에서 최댓값을 리턴                  |
| `Key delMax()`       | 우선순위 큐에서 최댓값을 삭제하고 리턴             |
| `boolean isEmpty()`  | 우선순위 큐가 비어있는지 검사                  |
| `int size()`         | 우선순위 큐에 들어있는 항목의 개수를 리턴           |

### 우선순위 큐 클라이언트

- 매우 큰 _N_ 개의 문자열을 스트림으로 입력받아 가장 긴 _M_ 개의 문자열을 출력
    - e.g. 1억개의 문자열 중에서 가장 긴 10개의 문자열을 출력하기
    - 스트림 : 금융 거래정보, 서비스 요청 정보, 과학 실험 결과 등등
- 입력 스트림이 너무 크면 모두 정렬하는 것은 비효율적
- 접근방법 : 새로 들어온 키를 그간 쌓여진 M개의 가장 큰 키와 비교

```java
public class TopM {

    public static void main(String[] args) {
        // 입력 스트림에서 최댓값 항목 M개의 라인을 출력
        int M = Integer.parseInt(args[0]);
        MinPQ<Transaction> pq = new MinPQ<Transaction>(M + 1);

        while (StdIn.hasNextLine()) {
            // 우선순위 큐에 M개 이상의 항목이 들어가면 가장 작은 항목을 삭제
            pq.insert(new Transaction(StdIn.readLine()));
            if (pq.size() > M) {
                pq.delMin();
            }
        }

        Stack<Transaction> stack = new Stack<Transaction>();
        while (!pq.isEmpty()) {
            stack.push(pq.delMin());
        }

        stack.forEach(System.out::println);
    }
}

```

#### N개의 항목 스트림에서 가장 큰 M개를 찾는 비용

| 클라이언트        | 시간      | 공간  |
|--------------|---------|-----|
| 정렬           | _NlogN_ | _N_ |
| 기초적인 우선순위 큐  | _NM_    | _M_ |
| 힙 기반의 우선순위 큐 | _NlogN_ | _M_ |

## 기초적인 구현

| 데이터 구조   | 삽입     | 최댓값 항목 삭제 |
|----------|--------|-----------|
| 배열 (정렬)  | _N_    | 1         |
| 배열 (비정렬) | 1      | _N_       |
| 힙        | _logN_ | _logN_    |

- 비정렬 시퀀스 : Lazy
    - 필요할떄까지 (`pop()`) 정렬 작업을 미룸
- 정렬 시퀀스 : Eager
    - 삽입할 때마다 (`push()`) 정렬 작업을 수행
- 힙은 삽입/삭제 모두 logN 시간 안에 수행

### 배열 표현 (비정렬)

- stack을 기반으로 가장 단순하게 구현
- 삽입 : stack에 `push()`
- 최댓값 항목 삭제
    - 선택정렬 내부 루프의 최댓값 키 찾기
    - stack 의 `pop()` 에서 항목을 삭제

```java
public class TopM {
    public static void main(String[] args) {
        // 입력 스트림에서 최댓값 항목 M개의 라인을 출력
        int M = Integer.parseInt(args[0]);
        MinPQ<Transaction> pq = new MinPQ<Transaction>(M + 1);

        while (StdIn.hasNextLine()) {
            // 우선순위 큐에 M개 이상의 항목이 들어가면 가장 작은 항목을 삭제
            pq.insert(new Transaction(StdIn.readLine()));
            if (pq.size() > M) {
                pq.delMin();
            }
        }

        Stack<Transaction> stack = new Stack<Transaction>();
        while (!pq.isEmpty()) {
            stack.push(pq.delMin());
        }

        stack.forEach(System.out::println);
    }
}
```

### 배열 표현 (정렬 상태)

- 가장 큰 항목이 항상 오른쪽 끝에 있게 하기
- 최댓값 항목 삭제 : stack의 `pop()`
- 삽입 시 큰 항목을 우측으로 한 칸씩 옮겨서 키들이 배열에 정렬된 상태로 존재하게 함

### 연결리스트 표현

- `pop()` 이 최댓값을 찾게 하고, `push()` 가 키 값을 역순으로 저장하게 하기

![img_21.png](img_21.png)

## 힙(heap)의 정의

- 이진 힙(binary heap)은 우선순위 큐의 기본 동작을 효율적으로 하게 해주는 자료구조
- 이진 힙에서 키들을 배열에 저장 시 각 키는 차례대로 자신에게 추가적으로 연결된 다른 두 키보다 크거나 같음
    - 마치, 이진 트리에서 각 키의 갓ㄴ언을 따라 더 작은 두 키가 연결됨
- **힙 정렬 : 이진 트리에서 두 자식 노드가 부모 노드보다 작으면 이 이진트리는 힙-정렬 되었다**
- **힙 정렬된 이진 트리의 가장 큰 키는 루트노드다**

### 이진 힙의 표현

![img_22.png](img_22.png)

- 키마다 링크가 3개 필요 (상위 1, 하위 2)
- 링크보다 이진 트리가 더 표현이 편함
- 루트 노드를 위치 시키고, 아래로 (왼->오) 내려가면서 자식 노드를 채워나감
- 이진 힙 (binary heap) : 힙 정렬된 완전 이진 트리 노드들이 레벨 순서대로 나열된 배열
    - (단, 루트 노드는 a[1]에 위치)

![img_23.png](img_23.png)

- a[K] 의 자식 노드는 a[2K] 와 a[2K+1] 이다
- a[K] 의 부모 노드는 a[K/2] 이다

#### 크기가 N인 완전 이진 트리의 높이는 logN에 가깝다

- 장점 1. 삽입, 최대 항목 삭제 작업을 logN 시간 안에 수행
- 장점 2. 포인터가 필요 없고, 트리 위아래를 탐색할 떄 logN 시간 안에 수행

## 힙을 이용한 알고리즘

- 크기 N인 힙은 크기 N+1 인 private 배열 `pq[]`를 사용
    - `pq[1]~pq[N]` : 실제 원소
- **힙 복구 작업 (reheapifying)** : 힙 조건을 만족하지 않는 단순 작업 진행 후 다시 힙을 순회하면서 조건에 만족하게 하는 재작업

````
// 원소 i와 j 비교
private boolean less(int i, int j){
    return pq[i].compareTo(pq[j]) < 0;
}

// 원소 i와 j 교환
private void exch(int i, int j){
    Key t = pq[i];
    pq[i] = pq[j];
    pq[j] = t;
}
````

- 경우의 수 1. 특정 노드의 우선순위가 증가되면 (or 리프 노드에 새로운 노드가 추가된 경우), 힙을 거슬러 올라가면서 힙의순서 수정
- 경우의 수 2. 특정 노드의 우선순위가 낮아지면 (e.g. 루트 노드를 더 작은 노드로 수정했을 떄), 힙을 내려가면서 힙의 순서를 수정

### 상향식 힙 복구 (swim)

TODO. 이미지

- 특정 노드가 부모 노드보다 커졌을 때
- 복구 방법 : 해당 노드를 부모 노드와 교환
    - 교환 후에는 해당 노드가 자식 노드들보다 큰 상태가 됨
    - 그래도 바뀐 위치의 부모보다 자신이 클 수 있음
    - 반복적으로 힙을 올라가면서 교환 (더 큰 노드를 만나거나, 루트노드를 만나면 중단)
- `swim()` 에서 메서드 안에서 힙 순서가 어긋나는 경우는 위치 `k`의 노드가 부모보다 큰 경우 하나로만 되도록 관리
    - 위치가 `k`인 노드의 부모노드는 `k/2`에 위치
- 예시 : 힙이 회사의 조직도라면? 신규 사원 입사 시
    - 신규 사원의 직급에 맞는 위치를 찾을 때까지 반복해서 승진해서 위치

````
// 상향식 힙 복구 구현
// k : 복구해야하는 노드의 인덱스 k
private void swim(int k){

    // (루트노드가 아님 and 부모보다 큰 경우) 반복
    while (k > 1 && less(k/2, k)) {
        exch(k/2, k); // 부모와 교환
        k = k/2;
    }
}
````

### 하향식 힙 복구 (slink)

TODO. 이미지

- 특정 노드가 자식 노드 중 하나보다 작아졌을 때
- 복구 방법 : 해당 노드를 자식 노드중 더 큰 노드와 교환
    - 반복적으로 힙을 내려가면서 (두 자식 노드 모두 부모보다 작거나 같을때까지) 반복
- `sink()` 에서 `k` 노드의 자식의 위치는 `2k`, `2k+1`
- 예시 : 힙이 회사의 조직도라면? 차장이 퇴사하고 과장이 입사했을 때,
    1. 차장 노드 제거 후 과장 노드로 대체
    2. 과장 노드를 부하직원 쪽으로 반복해서 힙 복구 (재위치)

````
// 하향식 힙 복구의 구현
// k : 복구해야하는 노드의 인덱스 k
private void sink(int k){
    
    // 자식노드보다 같거나 작으면 반복
    while (2*k <= N) {
        int j = 2*k; // 자식 노드
        if(j < N && less(j, j+1) j++; //자식노드랑 비교 후, 형제노드와 비교
        if(!less(k, j)) break; //자식노드보다 크면 break
         
        exch(k, j); // 자식이랑 교환
        k = j;
    }
}

````

### 삽입

1. 배열의 끝에 새로운 키 추가
2. 힙 사이즈 늘림
3. `swim()` (상향식 복구)

### 최대 항목 삭제

1. 루트노드 (가장 큰 항목)에서 꺼냄
2. 힙의 바닥에 있는 항목을 루트노드로 이동
3. 힙의 크기 줄임
4. 루트 노드로 `slink()` (하향식 복구)

TODO. 이미지

```java

public class MaxPQ<Key extends Comparable<Key>> {

    private Key[] pq; // 힙 정렬된 완전 이진 트리
    private int N = 0; // pq[1..N]만 사용, pq[0]은 비워둠

    public MaxPQ(int maxN) {
        this.pq = (Key[]) new Comparable[maxN + 1];
    }

    public boolean isEmpty() {
        return N == 0;
    }

    public int size() {
        return N;
    }

    /**
     * N을 증분하여, 마지막 인덱스에 새로운 키 삽입
     *
     * @param v
     */
    public void insert(Key v) {
        pq[++N] = v;
        swim(N);
    }

    /**
     * 루트노드를 꺼내고, 마지막 항목을 루트노드로 옮긴 후 하향식 복구
     *
     * @return
     */
    public Key delMax() {
        Key max = pq[1]; // 루트 노드
        exch(1, N--); // 마지막 항목과 교환
        pq[N + 1] = null; // 로이터링 방지 (로이터링 : 안쓰는 메모리 점유)
        sink(1);
        return max;
    }

    private void swim(int k) {

        while (k > 1 && less(k / 2, k)) {
            exch(k / 2, k);
            k = k / 2;
        }
    }

    private void sink(int k) {
        while (2 * k <= N) {
            int j = 2 * k;
            if (j < N && less(j, j + 1)) j++;
            if (!less(k, j)) break;

            exch(k, j);
            k = j;
        }
    }

    private boolean less(int i, int j) {
        return pq[i].compareTo(pq[j]) < 0;
    }

    private void exch(int i, int j) {
        Key t = pq[i];
        pq[i] = pq[j];
        pq[j] = t;
    }
}
```

// TODO. 이미지

#### 명제 : N개의 키를 가진 우선순위 큐에서 삽입 작업은 1+logN 이하의 비교연산을 소모, 최대 키 삭제 작업은 2logN이하의 비교연산 소모

- 두 작업 모두 루트노드부터 리프노드까지 경로 사용
- 링크 수는 logN 이하
- 최대 키 항목 삭제 작업은 노드마다 2개의 비교연산 수행
    - 비교연산 1. 자식 노드 2개 중 더 큰 자식 노드 판별
    - 비교연산 2. 자식노드 상승 여부 판별

### 다중 힙

- 3중 트리 방식으로 힙코드 작성 가능
- 위치 `k` 보다 같거나 큰 항목을 `3k-1, 3k, 3k+1` 에 위치
- 임의의 값 `d` 만큼의 `d`중 트리 가능
- trade-off : `d` 가 클수록
    - 트리 높이가 낮아짐
    - `d` 개의 자식 중 가장 큰 항목을 찾는 비용 증가

### 배열 크기 조정

- 배열의 크기를 자동으로 조절하는 방법 : `insert()`, `delMax()` 배열의 크기를 2배로 늘리고, 줄임
- 클라이언트는 힙의 크기를 신경 쓰지 않아도 됨

### 키 값의 불변성

- 클라이언트는 키 값을 변경 할 수 없다고 가정해야함
    - 키 값을 수정하면 힙의 정렬이 어긋남
- 클라이언트가 무슨 작업을 하건 힙의 정렬을 유지하도록 코딩 가능
    - 성능 저하

### 인덱스 방식 우선순위 큐

- 클라이언트에게 우선순위 큐의 항목에 직접 접근을 허용해야할 수도 있음
- 방법 : 각 항목마다 정수로된 식별자로 인덱스값 부여

| 메서드                            | 설명                                          |
|--------------------------------|---------------------------------------------|
| IndexMinPQ(int maxN)           | 용량이 maxN인 우선순위 큐, 생성 가능한 인덱스 범위는 0~(maxN-1) |
| void insert(int i, key key)    | 인덱스 i에 key 삽입                               |
| void changeKye(int i, Key key) | 인덱스 i의 key 변경                               |
| boolean contains(int i)        | 인덱스 i에 key 존재 여부                            |
| void delete(int i)             | 인덱스 i의 key 삭제                               |
| Key minKey()                   | 가장 작은 키                                     |
| int minIndex()                 | 가장 작은 인덱스                                   |
| int delMin()                   | 가장 작은 키와 인덱스 삭제                             |
| boolean isEmpty()              | 우선순위 큐가 비어있는가                               |
| int size()                     | 우선순위 큐의 저장된 키 개수                            |
| Key keyOf(int i)               | 인덱스 i의 키                                    |

- `IndexMinPQ` : 가장 작은 키에 빠르게 접근 가능한 특수 배열

#### 크기 N인 힙의 인덱스 기반 우선순위 큐 최악 조건

| 작업          | 비교 횟수 증가 오더 |
|-------------|-------------|
| insert()    | logN        |
| changeKey() | logN        |
| contains()  | 1           |
| delete()    | logN        |
| minKey()    | 1           |
| minIndex()  | 1           |
| delMin()    | logN        |

// TODO. 북사이트 : IndexMaxPQ 구현 코드

### 인덱스 기반 우선순위 큐의 클라이언트

- 인덱스 기반 우선순위 큐를 사용하여 다중 병합 문제 해결
- 복수의 정렬된 입력 스트림을 병합해서 하나의 정렬된 스트림으로 출력
    - 공간이 충분하다면, 두 스트림을 모두 배열에 저장하여 정렬하면 됨
- 우선순위 큐를 사용하면, 공간 크기에 상관 없이 정렬 후 출력 가능

// TODO. Multiway

1. 복수의 정렬된 스트림을 받음
2. `streams[]` 초기화 작업
3. 반복루프
    1. 큐에서 가장 작은 문자열 출력 후 해당 항목을 큐에서 삭제
    2. 입력 스트림에서 새로운 문자열을 가져와 큐에 추가

## 힙-정렬