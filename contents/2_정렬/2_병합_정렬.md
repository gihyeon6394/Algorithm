# 2. 병합 정렬

- 즉석 (in-place) 병합의 추상화
- 하향식 (top-down) 병합 정렬
- 상향식 (bottom-up) 병합 정렬
- 정렬의 복잡도

---

![img_5.png](img_5.png)

- 병합 : 두개의 정렬된 배열을 하나의 큰 정렬된 배열로 합침
- 즉, 배열 정렬시 반으로 나누어 각각 절반에 대해 재귀적으로 정렬을 수행한 다음 결과 병합
- 크기가 _N_ 인 배열을 정렬하는데 _NlogN_ 시간 소요
- 단점 : _N_ 만큼의 메모리 공간이 필요

## 즉석 (in-place) 병합의 추상화

1. 병합 결과를 담을 새로운 배열을 선언
2. 분할된 두 병렬을 하나의 배열로 병합
    - 병합 시, 양쪽 배열의 첫번째 원소를 비교하여 더 작은 원소를 결과 배열에 추가

- 문제점 : 배열이 클수록 1번에서 선언할 배열의 크기가 커짐
- 해결방법 : 원본 배열 안에서 분할하고, 병합 결과를 원본 배열에 저장

![img_6.png](img_6.png)

````
// a 배열의 정렬된 a[lo..mid]와 정렬된 a[mid+1..hi]를 병합
private static void merge(Comparable[] a, int lo, int mid, int hi) {

  int i = lo, j = mid + 1;

  for (int k = lo; k <= hi; k++) {
      // a[lo..hi]를 aux[lo..hi]에 복사
      aux[k] = a[k];
  }

  for (int k = lo; k <= hi; k++) {
      // 병합된 결과를 a[lo..hi]에 저장
      if (i > mid) a[k] = aux[j++]; // 왼쪽 절반 소진
      else if (j > hi) a[k] = aux[i++]; // 오른쪽 절반 소진
      else if (less(aux[j], aux[i])) a[k] = aux[j++]; // 오른쪽이 더 작으면 오른쪽 원소 삽입
      else a[k] = aux[i++]; // 왼쪽이 더 작으면 왼쪽 원소 삽입
  }
}
````

## 하향식 (top-down) 병합 정렬

## 상향식 (bottom-up) 병합 정렬

## 정렬의 복잡도

