# 4. 해시 테이블

- 해시 함수
- 개별 체이닝 (chaining) 해싱
- 선형-탐지 (linear-probing)를 이용한 해싱
- 가변 크기 배열
- 메모리

---

- 키가 작은 정숫값이라면 배열의 인덱스를 키값으로 사용하여 테이블을 구성할 수 있음
- 하지만 키가 문자열이나 객체처럼 복잡한 데이터 타입이면 배열의 인덱스를 키로 사용하기 어려움
- 해싱 (hashing) : 키를 산술 연산해서 배열 인덱스로 변환하여 값에 접근
- 요소 1. 해시 함수 (hash function) : 탐색 키를 배열 인덱스로 변환하는 함수
    - 이상적이라면 서로 다른 키라면, 서로 다른 해시값 (인덱스)을 반환해야 함
    - 이상적이지 않은 경우를 대비하여 충돌 (collision)을 처리하는 방법이 필요

![img_32.png](img_32.png)

- 요소 2. 충돌 해소 단계 (collision resolution scheme) : 해시 함수가 서로 다른 키에 대해 같은 해시값을 반환할 때, 충돌을 해결하는 방법
    - 방법 1. 개별 체이닝 (chaining) : 해시 테이블의 각 슬롯에 연결 리스트를 저장
    - 방법 2. 선형-탐지 (linear-probing) : 충돌이 발생하면 다음 빈 슬롯을 찾아서 저장

### trade off : 공간 vs 시간

- 공간이 무한대라면, 모든 키에 대한 인덱스를 배열로 만들 수 있음
    - e.g. 대한민국 모든 주민번호가 키일 때,
        - 키 별로 1:1로 인덱스 값을 매핑한 배열을 만들 수 있음
- 시간이 무한대라면, 비순차 배열에서 순차 탐색
    - e.g. 대한민국 모든 주빈번호가 키일 때,
        - 모든 주민번호를 순차적으로 탐색해야 함
- 해싱은 두 가지 사이의 절충점을 찾는 기술

## 해시 함수

- M 개의 키-값 쌍을 가진 배열을 사용할 때
- 요구사항 1. 임의의 키를 [0, M-1] 범위의 정수로 변환
- 요구사항 2. [0, M-1] 사이에서 최대한 균등하게 분포
    - 특정 키에 대해 종속성이 없어야함
- 발상 1. 모든 키는 일련의 비트로 표현 가능 -> 비트 열의 범위에 해당하는 정숫값으로 매핑
    - 숫자 (e.g. 주민번호) -> 숫자 그대로 사용
    - 문자열 (e.g. 메일 주소) -> 문자열을 숫자로 변환 -> 숫자로 사용

### 전형적인 예제

- 미국 사회 보장번호 (SSN) : 9자리 숫자
    - 123-45-6789
    - 첫번쨰 필드 : 발행 지역
    - 나머지 필드 : 개인 식별
- 보장번호로 10억개까지 표현 가능
- 최악의 경우 : 10억개의 배열을 생성해두고, 각 배열에 값을 저장, 보장번호와 인덱스를 매핑
- 프로그램치 수백개 정도만 다룰수 있다면?
- M = 1000인 해시 테이블 사용
- 방법 1. 키에서 세자리 숫자를 따옴
    - 세번쨰 필드에서 세자리 숫자를 가져옴 e.g. 678
- 방법 2. 아홉자리 숫자 모두를 사용해 int를 만든 뒤 정수에 대한 해시 함수 적용

### 양의 정수

![img_33.png](img_33.png)

- modular hashing (모듈러 해싱) : 정수 해싱 시 가장 흔히 사용되는 방법
- 양의 정수 값 키 k를 M으로 나눈 나머지를 해시값으로 사용 `k % M`
- 배열의 크기 M은 소수 (prime number)
    - 소수가 아니면, 키의 모든 피트들이 변환에 기여하지 않아 해시값이 균등하게 분포되지 않을 수 있음
- e.g. 전화번호 지역코드가 사용되고, M=100이라면
    - 역사적으로 미국 전화번호 중간 필드는 0 or 1로 시작이 대부분
    - 0 or 1로 시작하는 전화번호가 많아지면, 해시값이 몰릴 수 있음 (20으로 몰림)
    - M=97로 해야 적당

### 부동소수점 숫자

- 키가 [0, 1] 사이의 실수라면 M을 곱해 정수로 바꾸어 [0, M-1] 사이의 정수로 해시
- 단점 : 직관적이지만 키의 최상위 비트가 더 많이 영향을 주고, 최하위 비트는 역할이 거의 없음
- 자바가 해결한 방법 : 부동소숫점 숫자의 이진수 표현에 무듈러 해싱

### 문자열

```
Stirng s = "임의의 키 값";
int hash = 0;
for (int i = 0; i < key.length(); i++) {
    hash = (R * hash + key.charAt(i)) % M;
}
```

- `charAt(i)` : 문자열의 i번째 문자의 16비트 양의 정수 값
- `R` : 기수 (radix) : 문자열의 문자 수

### 복합키

- 여러개의 정수 필드로 구성된 데이터 타입일 때
- String과 마찬가지로 모드 낙ㅂㅅ을 이어붙여 처리

````
int hash = (((day * R + month) % M) * R + year) % M;
````

### 자바의 해시 함수 관례

- 자바는 모든 데이터 타입이 32비트 정수 해시값을 리턴하는 `hashCode()` 메서드를 상속하게 함
- `hashCode()` 반드시 동일성 (equality)과 일관성 (consistency)을 만족해야 함
    - `a.equals(b)`가 참이면, `a.hashCode() == b.hashCode()`도 참
    - `a.equals(b)`가 거짓이면, `a.hashCode() == b.hashCode()`도 거짓
    - `a.hashCode() == b.hashCode()`가 참이면, `a.equals(b)`가 참일 수도 있고 거짓일 수도 있음
- TODO. 두 객체의 동일성은 해시 값이 아니라 `equals()` 메서드로 판단해야 한다고...? 왜..?

### hashCode() 값을 배열 인덱스로 변환하기

- 32비트 해시값을 M 크기의 배열 인덱스로 변환

````
private int hash(Key x) {
    return (x.hashCode() & 0x7fffffff) % M;
}
````

1. 부호 비트의 마스킹을 제거 : 32 비트 숫자를 31비트 양의 정수로 변환
2. 나머지 연산을 통해 M 크기의 배열 인덱스로 변환 (모듈러 해싱)

### 사용자 정의

- 클라이언트는 `hashCode()` 겨로가가 32 비트 숫자 범위 내에서 균일하게 분포하길 원함
- 즉, `x.hashCode()` 값은 가능한 값들 중에 동일한 확률로 나타아야함

````java
public class Transaction {
    private final String who;
    private final Date when;
    private final double amount;

    @Override
    public int hashCode() {
        int hash = 17;
        hash = 31 * hash + who.hashCode();
        hash = 31 * hash + when.hashCode();
        hash = 31 * hash + ((Double) amount).hashCode();
        return hash;
    }
}
````

### 소프트웨어 캐싱

- 해시가 오래걸리면 해시결과를 캐싱하는 것이 바람직
- 데이터 타입에 변수 `hash`를 추가하여 해시값을 저장
    - Java String 클래스 방법
- 좋은 해시 함수는 다음 특정을 만족
    - 특성 1. 일관성 : 같은 키는 같은 해시값
    - 특성 2. 효율성 : 해시가 효율적으로 빠르게 계산
    - 특성 3. 균등성 : 해시 값은 가능한 값들 중에 균일하게 분포

#### 균일 해싱 가정 : 우리가 사용하는 해시 함수 (`hashCode()`)는 서로 독립적인 값으로 정수 [0, M-1] 사이에 균등하게 분포시킨다

- 자바의 해시함수가 모든 임의 상황에서 만족할 수 없음
- 컴퓨터 과학 이론에서도 균일하고 독립적인 해시 값을 분포시키는 것은 연구 주제
- 1977년 카터 (L. Carter)와 와이스 (M. N. Wegman)는 해시 함수의 균등성을 측정하는 방법을 제안
    - 만약 어떤 해시 함수가 범용적이라면, 해시 함수는 키를 균일하게 분포시킨다.
        - 단, 독립성은 부분적으로만 확보된다 (즉, 키가 서로 독립적이지 않을 수 있다)
- 가이드
    - 충돌이 많이 일어날 가능성이 있는 함수 선택 X
    - 균일 해싱 가정을 만족하지 못하더라도 성능을 크게 저하시키지 않는다면, 충돌을 최소화하는 함수 선택

## 개별 체이닝 (chaining) 해싱

## 선형-탐지 (linear-probing)를 이용한 해싱

## 가변 크기 배열

## 메모리
