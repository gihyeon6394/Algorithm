# 5. 응용

- 어떤 심볼-테이블 구현을 사용해야하는가?
- SET (집합) API
- 사전 클라이언트
- 색인 (indexing) 클라이언트
- 희소 벡터 (Sparse vector)

---

- 심볼 테이블은 빠른 탐색 알고리즘에서 필수적으로 사용
- 활용 분야 : 유전자 데이터에서 패턴 찾기, 천체 관측 데이터 분석작업, 웹에서 정보 정리, 전자상 거래의 상품 검색 등
- 대표적인 응요 사례
    - 사전 및 색인 클라이언트 : 웹에서 데이터 저장용으로 사용되는 CSV 포맷으로 빠르고 유연하게 접근
    - 여러 파일들의 역순 색인을 생성해내는 색인 클라이언트
    - 심볼 테이블로 희소 행렬 표현하여 표준 구현으로 다루기 불가능한 문제 해결

## 어떤 심볼-테이블 구현을 사용해야하는가?

<table>
  <tr>
    <td rowspan="2">알고리즘 (데이터 구조)</td>
    <td colspan="2">최악 조건 비용 (N번 삽입 후)</td>
    <td colspan="2">평균 조건 비용 (N번 무작위 삽입 후)</td>
    <td rowspan="2">키 인터페이스</td>
    <td rowspan="2">메모리 (바이트)</td>
  </tr>
  <tr>
    <td>탐색</td>
    <td>삽입</td>
    <td>탐색 성공</td>
    <td>삽입</td>
  </tr>
  <tr>
    <td>순차 탐색 (비 순차 리스트)</td>
    <td>N</td>
    <td>N</td>
    <td>N/2</td>
    <td>N</td>
    <td>equals()</td>
    <td>48N</td>
  </tr> 
  <tr>
    <td>이진 탐색 (순차 배열)</td>
    <td>lgN</td>
    <td>N</td>
    <td>lgN</td>
    <td>N/2</td>
    <td>compareTo()</td>
    <td>16N</td>
  </tr>
  <tr>
    <td>이진 트리 탐색<td>
    <td>N</td>
    <td>N</td>
    <td>1.39lgN</td>
    <td>1.39lgN</td>
    <td>compareTo()</td>
    <td>64N</td>
  </tr>
  <tr>
    <td>2-3 트리 탐색 (레드-블랙 BST)</td>
    <td>2lgN</td>  
    <td>2lgN</td>
    <td>1.00lgN</td>
    <td>1.00lgN</td>
    <td>compareTo()</td>
    <td>64N</td>
  </tr>
    <tr>
        <td>개별 체이닝 (리스트의 배열)</td>
        <td>N</td>
        <td>N</td>
        <td>N/(2M)/td>
        <td>N/M/td>
        <td>equals() hashCode()</td>
        <td>48N + 32M</td>
    </tr>
    <tr>
        <td>선형 탐지 (병렬 배열)</td>
        <td>N</td>
        <td>N</td>
        <td>< 1.50></td>
        <td>< 2.50></td>
        <td>equals() hashCode()</td>
        <td>32N ~ 128N</td>
</table>

- 전형적인 응용 상황에서는 해시 테이블, 이진 탐색 트리 사이에서 선택
- BST 대비 해싱이 더 나은점 : 코드가 단순하고, 최적의 탐색 시간 (상수) 보장
- 해싱에 비해 BST가 더 나은점
    - 인터페이스가 더 단순하게 추상회 됨 : 해시 함수 설계 필요 없음
    - 레드-블랙 BST의 경우 최악의 조건 성능 보장
    - 더 많은 범위 작업 지원 e.g. rank(), select(), sort()

### 기본 타입

- 정수 숫자 키, 부동 소수점 숫자 값을 키/값 쌍으로 사용하는 경우 `Integer`, `Double` 클래스 사용
- 수 조개 규모의 탐색이 일어나면 참조 오버헤드가 커짐
- 따라서 `Key` 타입에 기본형을 사용하면 메모리 절약

### 중복 키

- 중복 키의 존재 가능성에 특별히 신경 쓸 것
- 중복키가 없다는 가정하에 클라이언트에게 중복 관리를 위임할 수도 있음
- 중복 키가 탐색되면 복수의 연관된 값들이 있을 수 있음
    - e.g. 전자상거래에서 고객 키에 대한 값으로 여러 거래내역

### 자바 라이브러리

- 레드-블랙 BST와 개별체이닝에 기반한 심볼 테이블 : `java.util.TreeMap`, `java.util.HashMap`
- `java.util.TreeMap` : 순차 심볼 테이블 API, `rank()`, `select()` 직접 지원안함
- `java.util.HashMap` : `SeparateChainingHashST` 구현과 유사
    - 가변 크기배열 사용해 부하 비율의 75% 이상을 사용하지 않도록 함
- `java.util.IdentityHashMap` : 참조 동일성을 기준으로 키 비교
    - 참조 동일성 (reference equality) : 두 객체가 동일한 객체를 참조하는지 여부
    - 객체 동일성 (object equality) : 두 객체가 같은 값을 가지는지 여부ㅣ

## SET (집합) API

## 사전 클라이언트

## 색인 (indexing) 클라이언트

## 희소 벡터 (Sparse vector)
