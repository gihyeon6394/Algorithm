# 5. 응용

- 어떤 심볼-테이블 구현을 사용해야하는가?
- SET (집합) API
- 사전 클라이언트
- 색인 (indexing) 클라이언트
- 희소 벡터 (Sparse vector)

---

- 심볼 테이블은 빠른 탐색 알고리즘에서 필수적으로 사용
- 활용 분야 : 유전자 데이터에서 패턴 찾기, 천체 관측 데이터 분석작업, 웹에서 정보 정리, 전자상 거래의 상품 검색 등
- 대표적인 응요 사례
    - 사전 및 색인 클라이언트 : 웹에서 데이터 저장용으로 사용되는 CSV 포맷으로 빠르고 유연하게 접근
    - 여러 파일들의 역순 색인을 생성해내는 색인 클라이언트
    - 심볼 테이블로 희소 행렬 표현하여 표준 구현으로 다루기 불가능한 문제 해결

## 어떤 심볼-테이블 구현을 사용해야하는가?

<table>
  <tr>
    <td rowspan="2">알고리즘 (데이터 구조)</td>
    <td colspan="2">최악 조건 비용 (N번 삽입 후)</td>
    <td colspan="2">평균 조건 비용 (N번 무작위 삽입 후)</td>
    <td rowspan="2">키 인터페이스</td>
    <td rowspan="2">메모리 (바이트)</td>
  </tr>
  <tr>
    <td>탐색</td>
    <td>삽입</td>
    <td>탐색 성공</td>
    <td>삽입</td>
  </tr>
  <tr>
    <td>순차 탐색 (비 순차 리스트)</td>
    <td>N</td>
    <td>N</td>
    <td>N/2</td>
    <td>N</td>
    <td>equals()</td>
    <td>48N</td>
  </tr> 
  <tr>
    <td>이진 탐색 (순차 배열)</td>
    <td>lgN</td>
    <td>N</td>
    <td>lgN</td>
    <td>N/2</td>
    <td>compareTo()</td>
    <td>16N</td>
  </tr>
  <tr>
    <td>이진 트리 탐색</td>
    <td>N</td>
    <td>N</td>
    <td>1.39lgN</td>
    <td>1.39lgN</td>
    <td>compareTo()</td>
    <td>64N</td>
  </tr>
  <tr>
    <td>2-3 트리 탐색 (레드-블랙 BST)</td>
    <td>2lgN</td>  
    <td>2lgN</td>
    <td>1.00lgN</td>
    <td>1.00lgN</td>
    <td>compareTo()</td>
    <td>64N</td>
  </tr>
  <tr>
    <td>개별 체이닝 (리스트의 배열)</td>
    <td>N</td>
    <td>N</td>
    <td>N/(2M)</td>
    <td>N/M</td>
    <td>equals() hashCode()</td>
    <td>48N + 32M</td>
  </tr>
  <tr>
    <td>선형 탐지 (병렬 배열)</td>
    <td>N</td>
    <td>N</td>
    <td>< 1.50</td>
    <td>< 2.50</td>
    <td>equals() hashCode()</td>
    <td>32N ~ 128N</td>
  </tr>
</table>

- 전형적인 응용 상황에서는 해시 테이블, 이진 탐색 트리 사이에서 선택
- BST 대비 해싱이 더 나은점 : 코드가 단순하고, 최적의 탐색 시간 (상수) 보장
- 해싱에 비해 BST가 더 나은점
    - 인터페이스가 더 단순하게 추상회 됨 : 해시 함수 설계 필요 없음
    - 레드-블랙 BST의 경우 최악의 조건 성능 보장
    - 더 많은 범위 작업 지원 e.g. rank(), select(), sort()
- 어떤 선택을 하더라도 기대성능을 보장하는지 반드시 테스트해보자

### 기본 타입

- 정수 숫자 키, 부동 소수점 숫자 값을 키/값 쌍으로 사용하는 경우 `Integer`, `Double` 클래스 사용
- 수 조개 규모의 탐색이 일어나면 참조 오버헤드가 커짐
- 따라서 `Key` 타입에 기본형을 사용하면 메모리 절약

### 중복 키

- 중복 키의 존재 가능성에 특별히 신경 쓸 것
- 중복키가 없다는 가정하에 클라이언트에게 중복 관리를 위임할 수도 있음
- 중복 키가 탐색되면 복수의 연관된 값들이 있을 수 있음
    - e.g. 전자상거래에서 고객 키에 대한 값으로 여러 거래내역

### 자바 라이브러리

- 레드-블랙 BST와 개별체이닝에 기반한 심볼 테이블 : `java.util.TreeMap`, `java.util.HashMap`
- `java.util.TreeMap` : 순차 심볼 테이블 API, `rank()`, `select()` 직접 지원안함
- `java.util.HashMap` : `SeparateChainingHashST` 구현과 유사
    - 가변 크기배열 사용해 부하 비율의 75% 이상을 사용하지 않도록 함
- `java.util.IdentityHashMap` : 참조 동일성을 기준으로 키 비교
    - 참조 동일성 (reference equality) : 두 객체가 동일한 객체를 참조하는지 여부
    - 객체 동일성 (object equality) : 두 객체가 같은 값을 가지는지 여부

## SET (집합) API

- 키만 존재하고 값은 필요 없을 때
- 즉, 키를 테이블에 삽입하고, 테이블에 키 존재 여부 검사만 하면 됨

|         | `SET()`             | 빈 집합 생성       |
|---------|---------------------|---------------|
| void    | `add(Key key)`      | 키 추가          |
| void    | `delete(Key key)`   | 키 삭제          |
| boolean | `contains(Key key)` | 키 존재 여부 검사    |
| boolean | `isEmpty()`         | 집합이 비어있는지 검사  |
| int     | `size()`            | 집합 크기 반환      |
| String  | `toString()`        | 집합에 대한 문자열 표현 |

- 합집합, 교집합, 여집합 같은 일반적인 집합 연산 추가를 위해 더 정교한 API 구현 필요
- 순차/비순차 버전의 집합 API 구현 가능
    - 순차 : 키를 `Comparable`로 정의하고, `compareTo()` 메서드를 사용해 키 비교, `min()`, `max()` 등 지원
- 필터 클라이언트 : 메모리가 부족할 때 모든 데이터를 메모리에 올리지 않고 필요한 데이터만 읽어들이는 클라이언트
    1. 표준 입력으로부터 문자열을 읽음
    2. 일부를 표준 출력으로 내보냄

### 중복 제거 Dedup

- dedup : de-duplication, 중복 제거
- 입력 받은 문자열 키 집합을 보관하면서 새로운 키 입력시
    - 이미 집합에 존재하는 키라면 무시
    - 존재하지 않는 키라면 집합에 추가
- 서로 다른 키 수에 메모리 점유 비례

```java
import java.util.HashSet;

public class DeDup {
    public static void main(String[] args) {
        HashSet<String> set = new HashSet<String>();
        while (!StdIn.isEmpty()) {
            String key = StdIn.readString();
            if (!set.contains(key)) {
                set.add(key);
                StdOut.println(key);
            }
        }
    }
}
```

### 화이트 리스트와 블랙 리스트

- 사전에 별도의 파일에 키를 정의
- 입력으로부터 키를 읽어들여 파일을 사용해 저장 여부를 선별
- 화이트 리스트 : 저장할 키 목록
    - 예시 : 이메일 애플리케이션
        - 화이트 리스트 : 허용된 이메일 주소 목록
        - 그 외는 모두 스팸 취급
- 블랙 리스트 : 저장하지 않을 키 목록
    - 예시 : 이메일 애플리케이션
        - 블랙 리스트 : 스팸 이메일 주소 목록
        - 그 외는 모두 허용
    - 전형적인 응용예시 : 신용카드 회사의 도난카드, 인터넷 라우터의 방화백 통과 패킷
    - 화이트 리스트의 크기가 너무 클때 유용

```java
import java.util.HashSet;

public class WhiteFilter {
    public static void main(String[] args) {
        HashSet<String> set = new HashSet<String>();
        In in = new In(args[0]);
        while (!in.isEmpty()) {
            String key = in.readString();
            set.add(key);
        }
        while (!StdIn.isEmpty()) {
            String key = StdIn.readString();
            if (set.contains(key)) {
                StdOut.println(key);
            }
        }
    }
}
``` 

## 사전 클라이언트

## 색인 (indexing) 클라이언트

## 희소 벡터 (Sparse vector)
