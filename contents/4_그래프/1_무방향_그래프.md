## 1. 무방향 그래프

- 용어
- 무방향 그래프 데이터 타입
- 깊이 우선 탐색 (Depth-First Search, DFS)
- 경로 찾기
- 너비 우선 탐색 (Breadth-First Search, BFS)
- 연결 컴포넌트
- 심볼 그래프
- 요약

---

![img.png](img.png)

### 정의 : 그래프는 정점의 집합과 그 집합의 정점 쌍을 연결하는 간선의 모음이다.

- 그래프 모델 : 정점을 간선으로 연결한 것
- 무방향 그래프 : 가장 단순한 모델
- 각 정점을 구분하는 관례
    - V개 정점 그래프에서 각 정점의 이름을 0부터 V-1까지의 정수로 지정
    - 정점 이름을 배열의 인덱스로 사용 가능
- v-w or w-v : 정점 v와 w를 연결하는 간선
- 그림으로 표현시
    - 원 : 정점
    - 원과 원의 연결 선분 : 간선

### 특이 조건

- 자기 순환 (self-loop) : 정점이 자기 자신과 연결된 순환 간선
- 다중 간선 (parallel edges) : 두 정점을 연결하는 두 개 이상의 간선
    - 다중 그래프 : 다중 간선이 있는 그래프
- 단순 그래프 : 자기 순환과 다중 간선이 없는 그래프

## 용어

![img_1.png](img_1.png)

![img_2.png](img_2.png)

![img_3.png](img_3.png)

- 인접한다 (adjacent to) : 두 정점이 간선으로 연결되어 있는 경우
- 부속한다 (incident to) : 정점이 간선에 연결되어 있는 경우
- 차수 (degree) : 정점에 부속된 간선의 수
- 서브그래프 (subgraph) : 그래프를 이루는 간선들의 부분집합

> ### 정의
> - 경로 : 간선으로 연결된 정점들의 나열
> - 단순경로 : 반복되는 정점이 없는 경로
> - 순환 : 출발 정점과 도착 정점이 같은 같은 간선이 하나라도 존재하는 경로
> - 단순 순환 : 반복되는 간선이나 정점이 없는 순환 경로 (출발/도착 정점 예외)
> - 경로 (순환)의 길이 : 간선의 개수

- 일반 경로 (일반 순환) : 반복되는 정점이 있을수 있는 경우
- 연결되었다 : 어떤 두 정점을 모두 포함하는 경로가 존재하는 경우
- u-v-w-x : u에서 x로 가는 경로의 표현
- u-v-w-x-u : u로 다시 돌아가는 경로

> ### 정의
>
> - 그래프가 연결되었다 : 그래프 임의의 정점에서 다른 정점으로 가는 경로가 항상 존재하는 경우
> - 연결 컴포넌트 : 서로 연결된 정점들이 모두 모인 서브 그래프
> - 전체 그래프는 연결 컴포넌트들의 집합

| 그래프     | 비유                     |
|---------|------------------------|
| 정점      | 매듭, 구슬                 |
| 간선      | 밧줄, 실                  |
| 연결 컴포넌트 | 어떤 밧줄을 잡아당겼을 때 끌려오는 그룹 |
| 전체 그래프  | 그룹들의 집합                |

- 비순환 그래프 (acyclic graph) : 순환 경로가 없는 그래프

> ### 정의
>
> - 트리 : 연결된 비순환 그래프
> - 숲 : 서로 중첩되는 부분이 없는 트리들의 집합
> - 신장 트리 (spanning tree) : 어떤 연결된 그래프에 대해 속한 모든 정점들을 포함하는 트리
> - 신장 숲 (spanning forest) : 연결 컴포넌트들 각각에 대한 신장 트리들의 집합

- V개의 정점을 가지는 그래프 G가 트리가 되기 위한 조건
    - G는 V-1개의 간선을 가지고, 순환 경로는 없다
    - G는 V-1개의 간선을 가지고, 연결되어 있다.
    - G는 연결되어 있지만, 어떤 간선이든 하나를 제거하면 연결이 끊어진다.
    - G는 비순환 그래프지만, 어떤 두 정점이든 가선을 하나 추가하면 순환 경로가 생긴다.
    - G의 임의의 두 정점을 연결하는 경로는 모든 경우에 있어 정확히 하나만 존재한다.
- 그래프의 밀도 (density) : 간선으로 연결된 정점 쌍의 개수와 가능한 정점 쌍의 개수의 비율
- 희소 (sparse) 그래프 : 밀도가 낮은 그래프
    - 희소하다 : 간선의 개수가 V에 작은 상수 비율정도의 값
- 밀집 (dense) 그래프 : 밀도가 높은 그래프
    - 밀집하다 : 희소하지 않은 그래프
- 이분 그래프 (bipartite graph) : 모든 간선들이 두 그룹으로 완전히 나뉘어진 정점의 양쪽을 연결하는 그래프

## 무방향 그래프 데이터 타입

<table>
    <tr>
        <td colspan="2">
          public class Graph
        </td>
    </tr>
    <tr>
        <td>
            Graph (int V)
        </td>
        <td>
            간선 없이 V개의 정점을 가진 그래프 생성
        </td>
    </tr>
    <tr>
        <td>
            Graph(In in)
        </td>
        <td>
            입력 스트림으로부터 그래프 생성 (in은 2E+2개의 정수, V와 E는 정수, 간선은 정점 쌍의 리스트 E개)
        </td>
    </tr>
    <tr>
        <td>
            int V()
        </td>
        <td>
            정점의 개수 반환
        </td>
    </tr>
    <tr>
        <td>
            int E()
        </td>
        <td>
            간선의 개수 반환
        </td>
    </tr>
    <tr>
        <td>
            void addEdge(int v, int w)
        </td>
        <td>
            간선 v-w 추가
        </td>
    </tr>
    <tr>
        <td>
            Iterable&lt;Integer&gt; adj(int v)
        </td>
        <td>
            정점 v에 인접한 정점 리스트 반환
        </td>
    </tr>
    <tr>
        <td>
            String toString()
        </td>
        <td>
            그래프의 문자열 표현 반환
        </td>
    </tr>
</table>


![img_4.png](img_4.png)

```
// 주어진 정점의 차수 구하기
public static int degree(Graph G, int v) {
    int degree = 0;
    for (int w : G.adj(v)) degree++;
    return degree;
}

// 최대 차수 구하기
public static int maxDegree(Graph G) {
    int max = 0;
    for (int v = 0; v < G.V(); v++)
        if (degree(G, v) > max)
            max = degree(G, v);
    return max;
}

// 평균 차수 구하기
public static double avgDegree(Graph G) {
    return 2.0 * G.E() / G.V();
}

// 자기 순환의 개수 구하기
public static int numberOfSelfLoops(Graph G) {
    int count = 0;
    for (int v = 0; v < G.V(); v++)
        for (int w : G.adj(v))
            if (v == w) count++;
    return count / 2;
}

// 그래프의 인접 리스트 구조에 대한 문자열 표현
public String toString() {
    String s = V + " vertices, " + E + " edges\n";
    for (int v = 0; v < V; v++) {
        s += v + ": ";
        for (int w : this.adj(v))
            s += w + " ";
        s += "\n";
    }
    return s;
}
```

### 다른 표현 방법

| 기반 데이터 구조 | 공간 성능 | 간선 v-w 추가 성능 | w의 v인접 여부 검사 | v에 인접한 정점 순회 |
|-----------|-------|--------------|--------------|--------------|
| 간선 리스트    | E     | 1            | E            | E            |
| 인접 행렬     | V^2   | 1            | 1            | V            |
| 인접 리스트    | E+V   | 1            | degree(v)    | degree(v)    |
| 인접 집합     | E+V   | log(V)       | log(V)       | degree(v)    |

![img_5.png](img_5.png)

- 요구사항 1. 실제 응용에서 만날 수 있는 여러가지 그래프 형태를 감당할 수 있도록 높은 수준의 공간 효율성을 만족해야한다.
- 요구사항 2. 클라이언트에서 이용할 Graph 인스턴스 메서드들이 빠른속도로 동작할 수 있도록 높은 수준의 시간 효율성으로 구현될 수 있어야 한다.
- 후보 데이터 구조
    - 후보 1. 인접 행렬 데이터 구조
        - V * V 크기의 boolean 타입 배열에 간선 v-w가 존재하면 v행 w열의 값을 true로 설정
        - v^2개의 boolean 값 저장 공간 필요
        - 단점 : 정점의 수가 많을수록 공간 낭비
    - 후보 2. 간선 배열 데이터 구조
        - `Edge` 클래스 생성, 정점 두개의 연결을 의미하는 int 타입 인스턴스 변수 2개를 가짐
        - 단점 : 간선이 많을수록 시간 낭비
            - `adj()` 구현 시 모든 간선을 검사해야 함
    - 후보 3. 인접 리스트의 배열 데이터 구조
        - 각 정점마다 그에 인접한 정점 목록을 배열로 저장
        - 배열들을 리스트로 관리
        - 대부분의 응용 상황에서 공간/시간 효율성 만족

### 인접-리스트 데이터 구조

- 밀집하지 않은 그래프에서는 인접-리스트 데이터 구조가 표준으로 사용됨
- 어떤 정점이 주어지면 배열을 통해 즉각적으로 인접한 정점을 담은 리스트에 접근 가능
- `Bag` 데이터 타입 사용
    - `Bag`으로 간선 추가, 인접 정점 목록 순회 작업을 상수 시간에 완료
- 공간 사용량이 V+E에 비례
- 간선 추가 작업은 상수 시간 소요
- 정점 v에 인접한 정점 목록 순회 작업 시간은 정점 v 차수에 비례
- 동일한 그래프가 서로 다른 인접 리스트 배열로 표현될 수 있음
    - 인접 리스트 배열의 정점 순서는 그래프 생성 시 간선이 그래프에 추가된 순서를 따름

```java
public class Graph {
    private final int V; // 정점 개수
    private int E; // 간선 개수
    private Bag<Integer>[] adj; // 인접 리스트

    public Graph(int V) {
        this.V = V;
        this.E = 0;
        adj = (Bag<Integer>[]) new Bag[V]; // 각 정점에 대한 인접 리스트 생성
        for (int v = 0; v < V; v++)
            adj[v] = new Bag<Integer>();
    }

    public Graph(In in) {
        this(in.readInt()); // 정점 개수를 읽기
        int E = in.readInt(); // 간선 개수 읽기

        for (int i = 0; i < E; i++) {
            // 간선 추가
            int v = in.readInt(); // 정점 읽기
            int w = in.readInt(); // 다른 정점 읽기
            addEdge(v, w); // 간선 추가
        }
    }

    public int V() {
        return V;
    }

    public int E() {
        return E;
    }

    public void addEdge(int v, int w) {
        adj[v].add(w); // v의 인접 리스트에 w 추가
        adj[w].add(v); // w의 인접 리스트에 v 추가
        E++;
    }

    public Iterable<Integer> adj(int v) {
        return adj[v];
    }
}
```

#### 추가 고려 대상 API

- 정점의 추가 / 삭제
    - 배열 (정점을 인덱스로 하는)대신 심볼 테이블을 이용해볼 수 있음
    - 심볼 테이블을 사용하면 정점의 타입이 정수일 필요도 없어짐
- 간선의 삭제, 간선 v-w 존재 여부 검사
    - 인접 리스트 `Bag` 대신 `SET` 사용
    - 인접 집합 가능 (`SET`으로 다중 간선을 금지 가능)

### 그래프 처리 디자인 패턴

- 그래프 표현 방법과 알고리즘 구현을 분리
- 각 작업 마다 적합한 구현 클래스를 작성
- 클라이언트는 필요 작업에 맞는 클래스를 사용
- 생성자에서는 클라이언트의 요청을 효율적으로 처리하기 위한 전처리 과정 수행

```java
public class TestSearch {
    // 원점 s에서 시작하는 그래프 G의 연결 컴포넌트 찾기
    public static void main(String[] args) {
        Graph G = new Graph(new In(args[0])); // 그래프
        int s = Integer.parseInt(args[1]); // 원점
        Search search = new Search(G, s);

        for (int v = 0; v < G.V(); v++)
            if (search.marked(v))
                StdOut.print(v + " ");
        StdOut.println();

        if (search.count() != G.V())
            StdOut.print("NOT ");
        StdOut.println("connected");
    }
}
```

<table>
    <tr>
        <td colspan="2">
            public class Search
        </td>
    </tr>
    <tr>
        <td>
            Search(Graph G, int s)
        </td>
        <td>
            원점 s에 연결된 정점들 찾기
        </td>
    </tr>
    <tr>
        <td>
            boolean marked(int v)
        </td>
        <td>
            정점 v가 원점 s에 연결되어 있는지 여부 반환
        </td>
    </tr>
    <tr>
        <td>
            int count()
        </td>
        <td>
            원점 s에 연결된 정점의 개수 반환
        </td>
</table>

- 원점 : 생성자에 인수로 전달되는 정점
- 생성자의 역할 : 그래프에서 원점에 연결된 다른 정점들을 찾는 것

## 깊이 우선 탐색 (Depth-First Search, DFS)

- 정점의 순회를 위해 서로 다른 순회 전략들이 있음
- 그 중에서 가장 단순하고 전통적인 방법이 깊이 우선 탐색

### 미로 찾기

| 미로  | 그래프 |
|-----|-----|
| 길   | 간선  |
| 갈림길 | 정점  |

- 미로 : 갈림길과 그 갈림길에 연결된 길로 이루어짐
- 트라모스의 탐험 (Trémaux's exploration) : 미로를 탐색하는 방법
    - 가보지 않은 아무 길이나 선택하고, 실을 풀어서 남기져 진행
    - 한번이라도 지나간 길이나 갈림길은 표시를 남김
    - 표시된 갈림길을 만나면 풀어둔 실을 따라 뒤로 되돌아감
    - 되돌아가다가 지나지 않은 길에 남아있는 갈림길이 있다면 위 작업 반복

### 준비 운동

- 연결 그래프를 저통적인 재귀적 방식으로 탐색하는 것이 트라모스의 탐험과 유사
- 깊이 우선 탐색 : 그래파 탐색마다 다음 동작을 하면서 정점을 방문하는 메서드를 재귀적으로 호출
    - 방문 했다는 표시
    - 인접한 정점 중 방문하지 않은 정점을 재귀적으로 방문

```java
// 깊이 우선 탐색
public class DepthFirstSearch {
    private boolean[] marked; // 정점 별 방문 여부
    private int count; // 방문한 정점 개수

    public DepthFirstSearch(Graph G, int s) {
        marked = new boolean[G.V()];
        dfs(G, s);
    }

    private void dfs(Graph G, int v) {
        marked[v] = true;
        count++;
        for (int w : G.adj(v))
            if (!marked[w]) // 방문하지 않은 정점이면
                dfs(G, w); // 재귀 호출
    }

    public boolean marked(int w) {
        return marked[w];
    }

    public int count() {
        return count;
    }

}
```

#### 명제 : DFS는 주어진 원점에 연결된 모든 정점들을 방문 표시하는데 그 정점들의 차수에 비례하는 시간 소요

### 단방향 통로

- 메서드 호출 후 리턴하는 과정 : 미로에서 길에 실을 풀어놓았다가 되짚어 가는 과정
    - 어떤 정점에 부속한 간선들을 모두 처리(탐색) 한 다음에 되돌아옴
- 어떤 통로(간선)을 처음 지나가거나, 표시된 정점에서 되돌아오면서 두번쨰로 지나가게됨
    - 표시되지 않은 정점 w에 대한 간선 v-w를 만나면, 재귀 호출
    - 이미 방문한 v-w를 건너 뛸때도 재귀 호출 (반대 방향 w-v를 만났을 때)
        - 이 떄는 v가 이미 방문된 상태라서 건너뛰게됨

### DFS의 동작 과정

- DFS는 그래프의 모든 정점을 방문하는데 사용됨
- 간선이 검사되고, 정점이 방문되는 순서는 그래프의 표현 상태에도 의존적임
- 그래프 첫번째 정점의 인접리스트 가장 앞에 있는 정점이 가장 먼저 방문됨
- DFS는 기대한것 보다 두배 오래 걸림
    - DFS는 각 간선을 두번씩 순회하고, 표시되는 정점도 두번씩 방문함

### 깊이 우선 탐색의 상세 동작 과정

````
6
8
0 5
2 4
2 3
1 2
0 1
3 4
3 5
0 2
````

````
// graph 데이터 의사 코드
val graph = Graph(
    0 = [2, 1, 5],
    1 = [0, 2],
    2 = [0, 1, 3, 4],
    3 = [2, 4, 5],
    4 = [2, 3],
    5 = [0, 3]
)
````

1. 0의 인접리스트에서 2를 방문
    1. dfs()에서 0을 방문 표시
    2. 2를 방문 (재귀호출)
        1. 2를 방문 표시
        2. 0을 방문 (실패, 이미 방문)
        3. 1을 방문 (재귀호출)
            1. 1을 방문 표시
            2. 0, 2 방문 (실패, 이미 방문)
        4. 3을 방문 (재귀호출)
            1. 3을 방문 표시
            2. 2, 4를 방문 (실패, 이미 방문)
            3. 5를 방문 (재귀호출)
                1. 5를 방문 표시
                2. 0, 3 방문 (실패, 이미 방문)
        5. 4를 방문 (재귀호출)
            1. 4를 방문 표시
            2. 2, 3 방문 (실패, 이미 방문)

- **연결성 검사** : 주어진 그래프에서 특정 두 정점이 연결되어 있는가? 그 그래프에서 연결 컴포넌트 개수는 몇개인가?
    - = 두 정점을 연결하는 경로가 존재하는가?
    - **단일 원점에서 시작하는 경로** : 그래프와 원점 s가 주어졌을때 s로부터 어떤 다른 정점 v로의 경로가 존재하는가?

## 경로 찾기

## 너비 우선 탐색 (Breadth-First Search, BFS)

## 연결 컴포넌트

## 심볼 그래프

## 요약