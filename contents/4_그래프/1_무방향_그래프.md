## 1. 무방향 그래프

- 용어
- 무방향 그래프 데이터 타입
- 깊이 우선 탐색 (Depth-Frist Search, DFS)
- 경로 찾기
- 너비 우선 탐색 (Breadth-First Search, BFS)
- 연결 컴포넌트
- 심볼 그래프
- 요약

---

![img.png](img.png)

### 정의 : 그래프는 정점의 집합과 그 집합의 정점 쌍을 연결하는 간선의 모음이다.

- 그래프 모델 : 정점을 간선으로 연결한 것
- 무방향 그래프 : 가장 단순한 모델
- 각 정점을 구분하는 관례
    - V개 정점 그래프에서 각 정점의 이름을 0부터 V-1까지의 정수로 지정
    - 정점 이름을 배열의 인덱스로 사용 가능
- v-w or w-v : 정점 v와 w를 연결하는 간선
- 그림으로 표현시
    - 원 : 정점
    - 원과 원의 연결 선분 : 간선

### 특이 조건

- 자기 순환 (self-loop) : 정점이 자기 자신과 연결된 순환 간선
- 다중 간선 (parallel edges) : 두 정점을 연결하는 두 개 이상의 간선
    - 다중 그래프 : 다중 간선이 있는 그래프
- 단순 그래프 : 자기 순환과 다중 간선이 없는 그래프

## 용어

![img_1.png](img_1.png)

![img_2.png](img_2.png)

![img_3.png](img_3.png)

- 인접한다 (adjacent to) : 두 정점이 간선으로 연결되어 있는 경우
- 부속한다 (incident to) : 정점이 간선에 연결되어 있는 경우
- 차수 (degree) : 정점에 부속된 간선의 수
- 서브그래프 (subgraph) : 그래프를 이루는 간선들의 부분집합

> ### 정의
> - 경로 : 간선으로 연결된 정점들의 나열
> - 단순경로 : 반복되는 정점이 없는 경로
> - 순환 : 출발 정점과 도착 정점이 같은 같은 간선이 하나라도 존재하는 경로
> - 단순 순환 : 반복되는 간선이나 정점이 없는 순환 경로 (출발/도착 정점 예외)
> - 경로 (순환)의 길이 : 간선의 개수

- 일반 경로 (일반 순환) : 반복되는 정점이 있을수 있는 경우
- 연결되었다 : 어떤 두 정점을 모두 포함하는 경로가 존재하는 경우
- u-v-w-x : u에서 x로 가는 경로의 표현
- u-v-w-x-u : u로 다시 돌아가는 경로

> ### 정의
>
> - 그래프가 연결되었다 : 그래프 임의의 정점에서 다른 정점으로 가는 경로가 항상 존재하는 경우
> - 연결 컴포넌트 : 서로 연결된 정점들이 모두 모인 서브 그래프
> - 전체 그래프는 연결 컴포넌트들의 집합

| 그래프     | 비유                     |
|---------|------------------------|
| 정점      | 매듭, 구슬                 |
| 간선      | 밧줄, 실                  |
| 연결 컴포넌트 | 어떤 밧줄을 잡아당겼을 때 끌려오는 그룹 |
| 전체 그래프  | 그룹들의 집합                |

- 비순환 그래프 (acyclic graph) : 순환 경로가 없는 그래프

> ### 정의
>
> - 트리 : 연결된 비순환 그래프
> - 숲 : 서로 중첩되는 부분이 없는 트리들의 집합
> - 신장 트리 (spanning tree) : 어떤 연결된 그래프에 대해 속한 모든 정점들을 포함하는 트리
> - 신장 숲 (spanning forest) : 연결 컴포넌트들 각각에 대한 신장 트리들의 집합

- V개의 정점을 가지는 그래프 G가 트리가 되기 위한 조건
    - G는 V-1개의 간선을 가지고, 순환 경로는 없다
    - G는 V-1개의 간선을 가지고, 연결되어 있다.
    - G는 연결되어 있지만, 어떤 간선이든 하나를 제거하면 연결이 끊어진다.
    - G는 비순환 그래프지만, 어떤 두 정점이든 가선을 하나 추가하면 순환 경로가 생긴다.
    - G의 임의의 두 정점을 연결하는 경로는 모든 경우에 있어 정확히 하나만 존재한다.
- 그래프의 밀도 (density) : 간선으로 연결된 정점 쌍의 개수와 가능한 정점 쌍의 개수의 비율
- 희소 (sparse) 그래프 : 밀도가 낮은 그래프
    - 희소하다 : 간선의 개수가 V에 작은 상수 비율정도의 값
- 밀집 (dense) 그래프 : 밀도가 높은 그래프
    - 밀집하다 : 희소하지 않은 그래프
- 이분 그래프 (bipartite graph) : 모든 간선들이 두 그룹으로 완전히 나뉘어진 정점의 양쪽을 연결하는 그래프

## 무방향 그래프 데이터 타입

<table>
    <tr>
        <td colspan="2">
          public class Graph
        </td>
    </tr>
    <tr>
        <td>
            Graph (int V)
        </td>
        <td>
            간선 없이 V개의 정점을 가진 그래프 생성
        </td>
    </tr>
    <tr>
        <td>
            Graph(In in)
        </td>
        <td>
            입력 스트림으로부터 그래프 생성 (in은 2E+2개의 정수, V와 E는 정수, 간선은 정점 쌍의 리스트 E개)
        </td>
    </tr>
    <tr>
        <td>
            int V()
        </td>
        <td>
            정점의 개수 반환
        </td>
    </tr>
    <tr>
        <td>
            int E()
        </td>
        <td>
            간선의 개수 반환
        </td>
    </tr>
    <tr>
        <td>
            void addEdge(int v, int w)
        </td>
        <td>
            간선 v-w 추가
        </td>
    </tr>
    <tr>
        <td>
            Iterable&lt;Integer&gt; adj(int v)
        </td>
        <td>
            정점 v에 인접한 정점 리스트 반환
        </td>
    </tr>
    <tr>
        <td>
            String toString()
        </td>
        <td>
            그래프의 문자열 표현 반환
        </td>
    </tr>
</table>


![img_4.png](img_4.png)

```
// 주어진 정점의 차수 구하기
public static int degree(Graph G, int v) {
    int degree = 0;
    for (int w : G.adj(v)) degree++;
    return degree;
}

// 최대 차수 구하기
public static int maxDegree(Graph G) {
    int max = 0;
    for (int v = 0; v < G.V(); v++)
        if (degree(G, v) > max)
            max = degree(G, v);
    return max;
}

// 평균 차수 구하기
public static double avgDegree(Graph G) {
    return 2.0 * G.E() / G.V();
}

// 자기 순환의 개수 구하기
public static int numberOfSelfLoops(Graph G) {
    int count = 0;
    for (int v = 0; v < G.V(); v++)
        for (int w : G.adj(v))
            if (v == w) count++;
    return count / 2;
}

// 그래프의 인접 리스트 구조에 대한 문자열 표현
public String toString() {
    String s = V + " vertices, " + E + " edges\n";
    for (int v = 0; v < V; v++) {
        s += v + ": ";
        for (int w : this.adj(v))
            s += w + " ";
        s += "\n";
    }
    return s;
}
```

### 다른 표현 방법

| 기반 데이터 구조 | 공간 성능 | 간선 v-w 추가 성능 | w의 v인접 여부 검사 | v에 인접한 정점 순회 |
|-----------|-------|--------------|--------------|--------------|
| 간선 리스트    | E     | 1            | E            | E            |
| 인접 행렬     | V^2   | 1            | 1            | V            |
| 인접 리스트    | E+V   | 1            | degree(v)    | degree(v)    |
| 인접 집합     | E+V   | log(V)       | log(V)       | degree(v)    |

![img_5.png](img_5.png)

- 요구사항 1. 실제 응용에서 만날 수 있는 여러가지 그래프 형태를 감당할 수 있도록 높은 수준의 공간 효율성을 만족해야한다.
- 요구사항 2. 클라이언트에서 이용할 Graph 인스턴스 메서드들이 빠른속도로 동작할 수 있도록 높은 수준의 시간 효율성으로 구현될 수 있어야 한다.
- 후보 데이터 구조
    - 후보 1. 인접 행렬 데이터 구조
        - V * V 크기의 boolean 타입 배열에 간선 v-w가 존재하면 v행 w열의 값을 true로 설정
        - v^2개의 boolean 값 저장 공간 필요
        - 단점 : 정점의 수가 많을수록 공간 낭비
    - 후보 2. 간선 배열 데이터 구조
        - `Edge` 클래스 생성, 정점 두개의 연결을 의미하는 int 타입 인스턴스 변수 2개를 가짐
        - 단점 : 간선이 많을수록 시간 낭비
            - `adj()` 구현 시 모든 간선을 검사해야 함
    - 후보 3. 인접 리스트의 배열 데이터 구조
        - 각 정점마다 그에 인접한 정점 목록을 배열로 저장
        - 배열들을 리스트로 관리
        - 대부분의 응용 상황에서 공간/시간 효율성 만족

### 인접-리스트 데이터 구조

- 밀집하지 않은 그래프에서는 인접-리스트 데이터 구조가 표준으로 사용됨
- 어떤 정점이 주어지면 배열을 통해 즉각적으로 인접한 정점을 담은 리스트에 접근 가능
- `Bag` 데이터 타입 사용
    - `Bag`으로 간선 추가, 인접 정점 목록 순회 작업을 상수 시간에 완료
- 공간 사용량이 V+E에 비례
- 간선 추가 작업은 상수 시간 소요
- 정점 v에 인접한 정점 목록 순회 작업 시간은 정점 v 차수에 비례
- 동일한 그래프가 서로 다른 인접 리스트 배열로 표현될 수 있음
    - 인접 리스트 배열의 정점 순서는 그래프 생성 시 간선이 그래프에 추가된 순서를 따름

```java
public class Graph {
    private final int V; // 정점 개수
    private int E; // 간선 개수
    private Bag<Integer>[] adj; // 인접 리스트

    public Graph(int V) {
        this.V = V;
        this.E = 0;
        adj = (Bag<Integer>[]) new Bag[V]; // 각 정점에 대한 인접 리스트 생성
        for (int v = 0; v < V; v++)
            adj[v] = new Bag<Integer>();
    }

    public Graph(In in) {
        this(in.readInt()); // 정점 개수를 읽기
        int E = in.readInt(); // 간선 개수 읽기

        for (int i = 0; i < E; i++) {
            // 간선 추가
            int v = in.readInt(); // 정점 읽기
            int w = in.readInt(); // 다른 정점 읽기
            addEdge(v, w); // 간선 추가
        }
    }

    public int V() {
        return V;
    }

    public int E() {
        return E;
    }

    public void addEdge(int v, int w) {
        adj[v].add(w); // v의 인접 리스트에 w 추가
        adj[w].add(v); // w의 인접 리스트에 v 추가
        E++;
    }

    public Iterable<Integer> adj(int v) {
        return adj[v];
    }
}
```

#### 추가 고려 대상 API

- 정점의 추가 / 삭제
    - 배열 (정점을 인덱스로 하는)대신 심볼 테이블을 이용해볼 수 있음
    - 심볼 테이블을 사용하면 정점의 타입이 정수일 필요도 없어짐
- 간선의 삭제, 간선 v-w 존재 여부 검사
    - 인접 리스트 `Bag` 대신 `SET` 사용
    - 인접 집합 가능 (`SET`으로 다중 간선을 금지 가능)

### 그래프 처리 디자인 패턴

- 그래프 표현 방법과 알고리즘 구현을 분리
- 각 작업 마다 적합한 구현 클래스를 작성
- 클라이언트는 필요 작업에 맞는 클래스를 사용
- 생성자에서는 클라이언트의 요청을 효율적으로 처리하기 위한 전처리 과정 수행


```java
public class TestSearch{
    // 원점 s에서 시작하는 그래프 G의 연결 컴포넌트 찾기
    public static void main(String[] args) {
        Graph G = new Graph(new In(args[0])); // 그래프
        int s = Integer.parseInt(args[1]); // 원점
        Search search = new Search(G, s);

        for (int v = 0; v < G.V(); v++)
            if (search.marked(v))
                StdOut.print(v + " ");
        StdOut.println();

        if (search.count() != G.V())
            StdOut.print("NOT ");
        StdOut.println("connected");
    }
}
```

<table>
    <tr>
        <td colspan="2">
            public class Search
        </td>
    </tr>
    <tr>
        <td>
            Search(Graph G, int s)
        </td>
        <td>
            원점 s에 연결된 정점들 찾기
        </td>
    </tr>
    <tr>
        <td>
            boolean marked(int v)
        </td>
        <td>
            정점 v가 원점 s에 연결되어 있는지 여부 반환
        </td>
    </tr>
    <tr>
        <td>
            int count()
        </td>
        <td>
            원점 s에 연결된 정점의 개수 반환
        </td>
</table>

- 원점 : 생성자에 인수로 전달되는 정점
- 생성자의 역할 : 그래프에서 원점에 연결된 다른 정점들을 찾는 것

## 깊이 우선 탐색 (Depth-Frist Search, DFS)

## 경로 찾기

## 너비 우선 탐색 (Breadth-First Search, BFS)

## 연결 컴포넌트

## 심볼 그래프

## 요약